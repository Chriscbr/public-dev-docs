"use strict";(self.webpackChunkmomento_docs=self.webpackChunkmomento_docs||[]).push([[2496],{2821:(e,t,n)=>{n(6540)},503:(e,t,n)=>{n.d(t,{F:()=>r});var o=n(2355),i=n(6540);const r=e=>{let{language:t,code:n}=e;return i.createElement(o.A,{language:t},n)}},7432:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var o=n(8168),i=(n(6540),n(5680)),r=(n(2821),n(503));const a={sidebar_position:2,sidebar_label:"Style Guide",title:"Style guide for Momento Node.js code",description:"Learn about the two different styles you can use when writing Momento Node.js code: the pattern matching style, or the simplified style.",keywords:["momento","cache","configuration","error handling","exceptions","sdk","production ready","typescript","node.js","nodejs","javascript","style guide","style","pattern matching","undefined"]},s="Momento Node.js Style Guide",l={unversionedId:"sdks/nodejs/style-guide",id:"sdks/nodejs/style-guide",title:"Style guide for Momento Node.js code",description:"Learn about the two different styles you can use when writing Momento Node.js code: the pattern matching style, or the simplified style.",source:"@site/docs/sdks/nodejs/style-guide.mdx",sourceDirName:"sdks/nodejs",slug:"/sdks/nodejs/style-guide",permalink:"/sdks/nodejs/style-guide",draft:!1,editUrl:"https://github.com/momentohq/public-dev-docs/tree/main/docs/sdks/nodejs/style-guide.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,sidebar_label:"Style Guide",title:"Style guide for Momento Node.js code",description:"Learn about the two different styles you can use when writing Momento Node.js code: the pattern matching style, or the simplified style.",keywords:["momento","cache","configuration","error handling","exceptions","sdk","production ready","typescript","node.js","nodejs","javascript","style guide","style","pattern matching","undefined"]}},d={},c=[{value:"Pattern matching style",id:"pattern-matching-style",level:2},{value:"Simplified style",id:"simplified-style",level:2}],h={toc:c},y="wrapper";function u(e){let{components:t,...n}=e;return(0,i.yg)(y,(0,o.A)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"momento-nodejs-style-guide"},"Momento Node.js Style Guide"),(0,i.yg)("p",null,"When writing Momento Node.js code, you can choose between two different styles: the pattern matching style, or the simplified style. This guide will help you understand the differences between the two styles, so that you can choose which one will work best for your project."),(0,i.yg)("h2",{id:"pattern-matching-style"},"Pattern matching style"),(0,i.yg)("p",null,"If you're not familiar with pattern matching, it is a mechanism that has become increasingly popular in modern programming languages. It allows you to match a value against a pattern to determine the type of the value, and then extract its properties. It's very useful when making network requests, where the type of the response can vary a great deal depending on whether the request was successful or not, because it gives you a way to write exhaustive, type-safe code that handles all possible response types."),(0,i.yg)("p",null,"For example, when you issue a Momento ",(0,i.yg)("inlineCode",{parentName:"p"},"get")," request (or any other cache read request), the response can be one of three types:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Hit")," - the key was found in the cache, and the value was returned"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Miss")," - the key was not found in the cache, so no value was returned"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Error")," - an error occurred while trying to read the value from the cache")),(0,i.yg)("p",null,"As you can imagine, a type-safe model of these different cases will expose very different properties depending on which type of response you recieve:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"A ",(0,i.yg)("inlineCode",{parentName:"li"},"Hit")," response will have a ",(0,i.yg)("inlineCode",{parentName:"li"},"value")," property - and it is guaranteed not to be ",(0,i.yg)("inlineCode",{parentName:"li"},"undefined"),", so you don't have to write any ",(0,i.yg)("inlineCode",{parentName:"li"},"if")," statements to handle the ",(0,i.yg)("inlineCode",{parentName:"li"},"undefined")," case."),(0,i.yg)("li",{parentName:"ul"},"A ",(0,i.yg)("inlineCode",{parentName:"li"},"Miss")," response will have no properties because no value was returned."),(0,i.yg)("li",{parentName:"ul"},"An ",(0,i.yg)("inlineCode",{parentName:"li"},"Error")," response will have an ",(0,i.yg)("inlineCode",{parentName:"li"},"errorCode")," property, indicating what type of error occurred.")),(0,i.yg)("p",null,"Using pattern matching, you can write code like this:"),(0,i.yg)(r.F,{language:"javascript",code:"const result = await cacheClient.get('test-cache', 'test-key');\nif (result instanceof CacheGet.Hit) {\n  console.log(`Retrieved value for key 'test-key': ${result.valueString()}`);\n} else if (result instanceof CacheGet.Miss) {\n  console.log(\"Key 'test-key' was not found in cache 'test-cache'\");\n} else if (result instanceof CacheGet.Error) {\n  throw new Error(\n    `An error occurred while attempting to get key 'test-key' from cache 'test-cache': ${result.errorCode()}: ${result.toString()}`\n  );\n}",mdxType:"SdkExampleCodeBlockImpl"}),(0,i.yg)("p",null,"In each branch of the ",(0,i.yg)("inlineCode",{parentName:"p"},"if")," statement, the TypeScript compiler is smart enough to recognize that it now knows the exact type of the ",(0,i.yg)("inlineCode",{parentName:"p"},"result")," object, so it will give you access to the correct properties based on which type it is. Because of this, you can catch many types of errors at compile time rather than finding out about them at run time. It also gives you a safer way to interact with the error objects than a normal try/catch block would."),(0,i.yg)("p",null,"If your primary goal is to write thorough, production-ready code with exhaustive handling of each different type of response you might receive for a request, then this pattern matching style is the way to go."),(0,i.yg)("p",null,"However, it can be more verbose and take longer to write than code you might be used to writing against other client libraries. If you prefer something more succinct, you might want to consider the simplified style."),(0,i.yg)("h2",{id:"simplified-style"},"Simplified style"),(0,i.yg)("p",null,"With the simplified style, you won't be doing any pattern matching or type checking. Instead, you will simply call the ",(0,i.yg)("inlineCode",{parentName:"p"},".value()")," method on the response object. For the case of a ",(0,i.yg)("inlineCode",{parentName:"p"},"Hit"),", you will get the value back; otherwise you will get back an ",(0,i.yg)("inlineCode",{parentName:"p"},"undefined"),"."),(0,i.yg)("p",null,"When using the simplified style you will probably want to enable the ",(0,i.yg)("inlineCode",{parentName:"p"},"withThrowOnErrors")," setting. By default, Momento always returns errors as part of the return value, as opposed to throwing them. But when using the simplified code style, if you call ",(0,i.yg)("inlineCode",{parentName:"p"},".value()")," on a response and you get back ",(0,i.yg)("inlineCode",{parentName:"p"},"undefined"),", you won't be able to tell if the response was a ",(0,i.yg)("inlineCode",{parentName:"p"},"Miss")," or an ",(0,i.yg)("inlineCode",{parentName:"p"},"Error"),". By enabling ",(0,i.yg)("inlineCode",{parentName:"p"},"withThrowOnErrors"),", you can tell the Momento client that you prefer for it to actually throw the errors when they occur."),(0,i.yg)("p",null,"Here's how to enable ",(0,i.yg)("inlineCode",{parentName:"p"},"withThrowOnErrors"),":"),(0,i.yg)(r.F,{language:"javascript",code:"const cacheClient = await CacheClient.create({\n  configuration: Configurations.Lambda.latest().withThrowOnErrors(true),\n  credentialProvider: CredentialProvider.fromEnvVar('MOMENTO_API_KEY'),\n  defaultTtlSeconds: 60,\n});",mdxType:"SdkExampleCodeBlockImpl"}),(0,i.yg)("p",null,"For more information on this topic, see the ",(0,i.yg)("a",{parentName:"p",href:"./config-and-error-handling"},"Configuration and Error Handling")," page."),(0,i.yg)("p",null,"Once you've enabled ",(0,i.yg)("inlineCode",{parentName:"p"},"withThrowOnErrors"),", you can write code like this:"),(0,i.yg)(r.F,{language:"javascript",code:"const result = (await cacheClient.get('test-cache', 'test-key')).value();\nif (result !== undefined) {\n  console.log(`Retrieved value for key 'test-key': ${result}`);\n} else {\n  console.log(\"Key 'test-key' was not found in cache 'test-cache'\");\n}",mdxType:"SdkExampleCodeBlockImpl"}),(0,i.yg)("p",null,"And if an error occurs, it will be thrown as an exception. You can catch the exception and handle it with a normal try/catch block, like this:"),(0,i.yg)(r.F,{language:"javascript",code:"try {\n  const result = (await cacheClient.get('test-cache', 'test-key')).value();\n  if (result !== undefined) {\n    console.log(`Retrieved value for key 'test-key': ${result}`);\n  } else {\n    console.log(\"Key 'test-key' was not found in cache 'test-cache'\");\n  }\n} catch (e) {\n  const momentoError = e as SdkError;\n  if (momentoError.errorCode() === MomentoErrorCode.LIMIT_EXCEEDED_ERROR) {\n    console.log('Request rate limit exceeded, may need to request a limit increase!');\n  } else {\n    throw new Error(\n      `An error occurred while attempting to get key 'test-key' from cache 'test-cache': ${momentoError.errorCode()}: ${momentoError.toString()}`\n    );\n  }\n}",mdxType:"SdkExampleCodeBlockImpl"}),(0,i.yg)("p",null,"The simplified style probably looks and feels more familiar to you compared to other Node.js client libraries you might have used in the past. It's also more succinct and faster to write than the pattern matching style. If you prefer to write code that is more concise, and you don't mind the trade-off of not having exhaustive type checking, then this style may be the right fit for you!"))}u.isMDXComponent=!0}}]);